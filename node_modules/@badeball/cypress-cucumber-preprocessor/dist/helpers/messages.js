"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTimestamp = createTimestamp;
exports.duration = duration;
exports.durationToNanoseconds = durationToNanoseconds;
exports.removeDuplicatedStepDefinitions = removeDuplicatedStepDefinitions;
exports.orderMessages = orderMessages;
const assertions_1 = require("./assertions");
function createTimestamp() {
    const now = new Date().getTime();
    const seconds = Math.floor(now / 1000);
    const nanos = (now - seconds * 1000) * 1000000;
    return {
        seconds,
        nanos,
    };
}
function duration(start, end) {
    return {
        seconds: end.seconds - start.seconds,
        nanos: end.nanos - start.nanos,
    };
}
function durationToNanoseconds(duration) {
    return Math.floor(duration.seconds * 1000000000 + duration.nanos);
}
function removeDuplicatedStepDefinitions(envelopes) {
    var _a;
    const seenDefinitions = [];
    const findSeenStepDefinition = (stepDefinition) => seenDefinitions.find((seenDefinition) => {
        var _a, _b;
        return (seenDefinition.uri === stepDefinition.sourceReference.uri &&
            seenDefinition.line === ((_a = stepDefinition.sourceReference.location) === null || _a === void 0 ? void 0 : _a.line) &&
            seenDefinition.column ===
                ((_b = stepDefinition.sourceReference.location) === null || _b === void 0 ? void 0 : _b.column));
    });
    for (let i = 0; i < envelopes.length; i++) {
        const { stepDefinition } = envelopes[i];
        if (stepDefinition &&
            stepDefinition.sourceReference.uri !== "not available") {
            const seenDefinition = findSeenStepDefinition(stepDefinition);
            if (seenDefinition) {
                // Remove this from the stack.
                envelopes.splice(i, 1);
                // Make sure we iterate over the "next".
                i--;
                // Find TestCase's in which this is used.
                for (let x = i; x < envelopes.length; x++) {
                    const { testCase } = envelopes[x];
                    if (testCase) {
                        for (const testStep of testCase.testSteps) {
                            // Replace ID's of spliced definition with ID of the prevously seen definition.
                            testStep.stepDefinitionIds = (_a = testStep.stepDefinitionIds) === null || _a === void 0 ? void 0 : _a.map((stepDefinitionId) => stepDefinitionId.replace(stepDefinition.id, seenDefinition.id));
                        }
                    }
                }
            }
            else {
                seenDefinitions.push({
                    id: stepDefinition.id,
                    uri: stepDefinition.sourceReference.uri,
                    line: stepDefinition.sourceReference.location.line,
                    column: stepDefinition.sourceReference.location.column,
                });
            }
        }
    }
}
/**
 * Some messages are emitted out-of-order, but not all. The messages below are the ones that need
 * additional sorting. The remaining messages are untouched.
 */
const BEFORE_TEST_RUN_STARTED = [
    "gherkinDocument",
    "hook",
    "meta",
    "parameterType",
    "pickle",
    "source",
    "stepDefinition",
];
function orderMessages(messages) {
    const toBeSorted = messages.map((message, index) => {
        const keys = Object.keys(message);
        (0, assertions_1.assert)(keys.length === 1, "Expected a message to have one, and only one, property");
        const [type] = keys;
        return {
            index,
            message,
            type,
        };
    });
    const isTestRunStarted = (message) => {
        return message.testRunStarted != null;
    };
    const isBeforeTestRunStarted = (type) => {
        return BEFORE_TEST_RUN_STARTED.indexOf(type) > -1;
    };
    return toBeSorted
        .sort((a, b) => {
        if (isTestRunStarted(a.message)) {
            return isBeforeTestRunStarted(b.type) ? 1 : -1;
        }
        else if (isTestRunStarted(b.message)) {
            return isBeforeTestRunStarted(a.type) ? -1 : 1;
        }
        else if (isBeforeTestRunStarted(a.type) &&
            !isBeforeTestRunStarted(b.type)) {
            return -1;
        }
        else if (!isBeforeTestRunStarted(a.type) &&
            isBeforeTestRunStarted(b.type)) {
            return 1;
        }
        else {
            return a.index - b.index;
        }
    })
        .map(({ message }) => message);
}
