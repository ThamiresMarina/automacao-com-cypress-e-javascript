"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHtmlStream = createHtmlStream;
exports.createJsonFormatter = createJsonFormatter;
exports.createUsageFormatter = createUsageFormatter;
exports.createPrettyFormatter = createPrettyFormatter;
const node_events_1 = require("node:events");
const cucumber_1 = require("@cucumber/cucumber");
const html_formatter_1 = require("@cucumber/html-formatter");
const pretty_formatter_1 = require("@cucumber/pretty-formatter");
const assertions_1 = require("./assertions");
const type_guards_1 = require("./type-guards");
function createHtmlStream() {
    return new html_formatter_1.CucumberHtmlStream(require.resolve("@cucumber/html-formatter/dist/main.css", {
        paths: [__dirname],
    }), require.resolve("@cucumber/html-formatter/dist/main.js", {
        paths: [__dirname],
    }));
}
function createJsonFormatter(envelopes, log) {
    const eventBroadcaster = new node_events_1.EventEmitter();
    const eventDataCollector = new cucumber_1.formatterHelpers.EventDataCollector(eventBroadcaster);
    const stepDefinitions = envelopes
        .map((m) => m.stepDefinition)
        .filter(type_guards_1.notNull)
        .map((s) => {
        var _a;
        return {
            id: s.id,
            uri: s.sourceReference.uri,
            line: (_a = s.sourceReference.location) === null || _a === void 0 ? void 0 : _a.line,
        };
    });
    new cucumber_1.JsonFormatter({
        eventBroadcaster,
        eventDataCollector,
        log(chunk) {
            (0, assertions_1.assertIsString)(chunk, "Expected a JSON output of string, but got " + typeof chunk);
            log(chunk);
        },
        supportCodeLibrary: {
            stepDefinitions,
        },
        colorFns: null,
        cwd: null,
        parsedArgvOptions: {},
        snippetBuilder: null,
        stream: null,
        cleanup: null,
    });
    return eventBroadcaster;
}
function createUsageFormatter(envelopes, log) {
    const eventBroadcaster = new node_events_1.EventEmitter();
    const eventDataCollector = new cucumber_1.formatterHelpers.EventDataCollector(eventBroadcaster);
    const stepDefinitions = envelopes
        .map((m) => m.stepDefinition)
        .filter(type_guards_1.notNull)
        .map((s) => {
        var _a;
        return {
            id: s.id,
            uri: s.sourceReference.uri,
            line: (_a = s.sourceReference.location) === null || _a === void 0 ? void 0 : _a.line,
            unwrappedCode: "",
            expression: {
                source: s.pattern.source,
                constructor: {
                    name: "foo",
                },
            },
        };
    });
    new cucumber_1.UsageFormatter({
        eventBroadcaster,
        eventDataCollector,
        log(chunk) {
            (0, assertions_1.assertIsString)(chunk, "Expected a JSON output of string, but got " + typeof chunk);
            log(chunk);
        },
        supportCodeLibrary: {
            stepDefinitions,
        },
        colorFns: null,
        cwd: null,
        parsedArgvOptions: {},
        snippetBuilder: null,
        stream: null,
        cleanup: null,
    });
    return eventBroadcaster;
}
function createPrettyFormatter(stream) {
    const eventBroadcaster = new node_events_1.EventEmitter();
    const printer = new pretty_formatter_1.PrettyPrinter({
        stream,
    });
    eventBroadcaster.on("envelope", (envelope) => printer.update(envelope));
    return eventBroadcaster;
}
